---
title: å…³äºå¤šçº¿ç¨‹çš„ä¸€äº›å®éªŒ
tags:
  - Java
  - å¤šçº¿ç¨‹
categories:
  - å°å®éªŒ
mathjax: true
published: 2025-03-30 19:13:02
abbrlink: thread
description: åšç‚¹å®éªŒæ¥ç¨å¾®å›é¡¾ä¸€ä¸‹Javaå¤šçº¿ç¨‹çš„å¸¸è§é—®é¢˜
---

# å†™åœ¨å‰é¢

éƒ½æ˜¯åšçš„æ¯”è¾ƒæµ…æ˜¾çš„ä¸€äº›å®éªŒï¼Œå¾ˆå¤šé—®é¢˜æ¥è‡ªäºå°æ—codingï¼Œå¾ˆå¤šå†…å®¹å…¶å®æŒºå…«è‚¡çš„ï¼Œä½†æ˜¯æˆ‘çš„è®°å¿†å¶å°”ä¼šå¸¦æœ‰ä¸€äº›å†…å­˜ç‰¹æ€§ï¼Œå…³æœºå°±å¿˜äº†ï¼Œæ‰€ä»¥ç°åœ¨æƒ³åŠæ³•é€šè¿‡ä¸€ç‚¹å®éªŒå’Œæ‰‹æ•²ä»£ç è½ä¸€ä¸‹ç›˜ã€‚

# æ­£å¼å†…å®¹

## çº¿ç¨‹

### è¿›ç¨‹å’Œçº¿ç¨‹çš„åŒºåˆ«

çº¿ç¨‹å’Œè¿›ç¨‹çš„åŒºåˆ«ï¼Œè¿™ä¸ªé—®é¢˜åœ¨å¾ˆå¤šåœ°æ–¹éƒ½ä¼šé‡åˆ°ï¼Œæ— è®ºæ˜¯åœ¨æ“ä½œç³»ç»Ÿè¿˜æ˜¯åœ¨Javaå¤šçº¿ç¨‹ã€‚

å…¶å®ä¸¤è€…æœ€å¤§çš„åŒºåˆ«å°±æ˜¯æ˜¯å¦äº«æœ‰ç‹¬ç«‹çš„æ‰§è¡Œç¯å¢ƒã€‚

æˆ‘ä»¬ä»¥Javaä¸¾ä¾‹ï¼ŒJVMçš„è¿è¡Œæ—¶å†…å­˜ä¸»è¦åŒ…æ‹¬è¿™æ ·äº”å—ï¼š

1. è™šæ‹Ÿæœºæ ˆ
2. å †ï¼ˆå¸¸é‡æ± ä»€ä¹ˆçš„å…¶å®ä¹Ÿåœ¨å †é‡Œï¼‰
3. å…ƒç©ºé—´
4. æœ¬åœ°æ–¹æ³•æ ˆ(Native)
5. ç¨‹åºè®¡æ•°å™¨

ä¸€ä¸ªè¿›ç¨‹ä¼šç‹¬ç«‹çš„äº«æœ‰è¿™å…¨éƒ¨çš„äº”ä¸ªè¿è¡Œæ—¶ç¯å¢ƒï¼Œè€Œçº¿ç¨‹åˆ™ä¸æ˜¯ï¼Œä¸€ä¸ªè¿›ç¨‹åˆ›å»ºä¸€ä¸ªçº¿ç¨‹ï¼Œè¿™ä¸ªçº¿ç¨‹ä¼šè·å¾—è‡ªå·±ç‹¬ç«‹çš„è™šæ‹Ÿæœºæ ˆã€ç¨‹åºè®¡æ•°å™¨ï¼Œå¯¹äºä»»æ„è¯¥è¿›ç¨‹åˆ›å»ºçš„çº¿ç¨‹ï¼Œå…¶ä½™ä¸‰è€…éƒ½æ˜¯å…±ç”¨çš„ã€‚

ä¸¾ä¸ªğŸŒ°ï¼š

```java
import java.util.concurrent.*;

public class SleepTry {

    public static void main(String[] args) throws InterruptedException, ExecutionException {
      	//è¿™ä¸ªStringBuilderæ˜¯åˆ›å»ºåœ¨è¿›ç¨‹å †ä¸Šçš„ï¼Œæ‰€ä»¥ä»–æ˜¯ä¼šè¢«å…±äº«çš„ï¼Œåˆ›å»ºçº¿ç¨‹çš„æ—¶å€™ä¼šæ‹·è´ä¸€ä¸ªå¼•ç”¨å‰¯æœ¬
      	//æ‰€ä»¥ä»»ä½•çº¿ç¨‹éƒ½å¯ä»¥æ“ä½œå¹¶ä¿®æ”¹ä»–ï¼Œä¿®æ”¹çš„å¹¶ä¸æ˜¯çº¿ç¨‹è‡ªå·±åˆ›å»ºçš„ï¼Œè€Œæ˜¯è¿›ç¨‹æ‰€åˆ›å»ºçš„
        StringBuilder sb =new StringBuilder();
        BlockingQueue<Runnable> bq =new LinkedBlockingQueue<>();
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5,10,1000L, TimeUnit.SECONDS,bq);
        CountDownLatch countDownLatch = new CountDownLatch(2);
        Runnable task2 = new Runnable() {
            @Override
            public void run() {
                synchronized (sb){
                    sb.append("I am Thread2\n");
                }
                countDownLatch.countDown();
            }
        };
        Future<?> feature2 =  threadPoolExecutor.submit(task2);
        feature2.get();
        System.out.println(sb.toString());
        threadPoolExecutor.shutdownNow();
    }
}
```

å…¶æ¬¡ï¼Œçº¿ç¨‹æ˜¯æ“ä½œç³»ç»Ÿè¿ç®—è°ƒåº¦çš„æœ€å°å•ä½ï¼Œå› ä¸ºçº¿ç¨‹ä¹‹é—´çš„èµ„æºå…±äº«æ€§è´¨ï¼Œå¯¼è‡´å®ƒçš„ä¸Šä¸‹æ–‡åˆ‡æ¢çš„å¼€é”€æ›´å°ã€‚åŒæ—¶ï¼Œä»–ä»¬å¯ä»¥é€šè¿‡è®¿é—®å…¨å±€å˜é‡æˆ–è€…é™æ€å˜é‡æ¥é€šä¿¡ã€‚

è¿›ç¨‹çš„åˆ›å»ºå’Œé”€æ¯éœ€è¦åˆ›å»ºå’Œé”€æ¯ä¸Šè¿°çš„å…¨éƒ¨èµ„æºï¼Œè€Œè¿›ç¨‹åªéœ€è¦åˆ›å»ºå’Œé”€æ¯ç¨‹åºè®¡æ•°å™¨å’Œå¯¹åº”çš„è¿è¡Œæ—¶æ ˆå³å¯ã€‚

### çº¿ç¨‹çš„åˆ›å»º

å¾ˆå¤šé¢ç»å–œæ¬¢æŠŠè¿™ä¸ªé—®é¢˜æ€»ç»“ä¸ºå››ç±»ï¼ŒåŒ…æ‹¬ç»§æ‰¿Threadã€å®ç°Runableå’ŒFutureTaskã€å®ç°Callableã€ä½¿ç”¨çº¿ç¨‹æ± ï¼Œä½†å…¶å®å½’æ ¹åˆ°åº•æ¥è¯´è¿˜æ˜¯ä¸‰ç±»ï¼Œå› ä¸ºFutureTaskè¿™ä¸ªæŠ½è±¡ç±»å®ç°äº†RunnableFutureæ¥å£ï¼ŒRunnableFutureè¿™ä¸ªæ¥å£ç»§æ‰¿äº†Futureæ¥å£å’ŒRunableæ¥å£ã€‚

```java
public class FutureTask<V> implements RunnableFuture<V> {
    /*
     * Revision notes: This differs from previous versions of this
     * class that relied on AbstractQueuedSynchronizer, mainly to
     * avoid surprising users about retaining interrupt status during
     * cancellation races. Sync control in the current design relies
     * on a "state" field updated via CAS to track completion, along
     * with a simple Treiber stack to hold waiting threads.
     */
```

```java
public interface RunnableFuture<V> extends Runnable, Future<V> {
    /**
     * Sets this Future to the result of its computation
     * unless it has been cancelled.
     */
    void run();
}
```

ç®€å•æ¥è¯´ï¼Œåˆ›å»ºçº¿ç¨‹æœ‰ä¸¤ä»¶äº‹æƒ…ï¼Œ1.ç¡®å®šçº¿ç¨‹è¦åšçš„äº‹æƒ…ï¼Œä¹Ÿå°±æ˜¯å®ç°runæˆ–è€…callæ–¹æ³•ã€‚2.å¯åŠ¨çº¿ç¨‹

æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç›´æ¥ç”¨ä¸€ä¸ªç±»ç»§æ‰¿Threadç„¶åé‡å†™runæ–¹æ³•ï¼Œå°±åƒè¿™æ ·ï¼

```java
class Thread3 extends Thread{
    @Override
    public void run(){
        System.out.println("Hello zhima.");
    }
}
Thread3 thread3 = new Thread3();
thread3.start();
```

æˆ–è€…å°±åƒä¸Šé¢é‚£æ ·å®ç°Runableæ¥å£ã€‚

å…³äºä¸ºä»€ä¹ˆè¦ä½¿ç”¨FutureTaskè¿™ä¸ªæŠ½è±¡ç±»ï¼Œå…¶å®ä¸»è¦æ˜¯å¸Œæœ›è·å¾—çº¿ç¨‹çš„è¿”å›å€¼ã€‚

å°±åƒä¸‹é¢è¿™æ ·ï¼š

```java
class Thread4 implements Callable<Integer>{

    @Override
    public Integer call() throws Exception {
        Random random = new Random();
        return random.nextInt(114514,114515);
    }
}
FutureTask<Integer> ft = new FutureTask<>(new Thread4());
Thread t4 = new Thread(ft);
t4.start();
Integer rand = ft.get();
System.out.println(rand);
//114514
```

å¦‚æœç”¨çº¿ç¨‹æ± å…¶å®åˆ›å»ºæ–¹æ³•ä¹Ÿå¾ˆå¤šï¼Œå¯ä»¥é€šè¿‡ä¸‹é¢å‡ ç§æ–¹æ³•

```java
//åˆ›å»ºå¤§å°å›ºå®šçš„çº¿ç¨‹æ± 
ExecutorService executorService = Executors.newFixedThreadPool(10);
//ä¹Ÿå¯ä»¥åˆ›å»ºä¸€ä¸ª
ExecutorService executorService1 = Executors.newSingleThreadExecutor();
//ä¹Ÿå¯ä»¥ç›´æ¥newä¸€ä¸ªThreadPoolExecutor
//è¦æŒ‡å®šçš„ä¸œè¥¿å°±æ¯”è¾ƒå¤šäº†ï¼ŒåŒ…æ‹¬æ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œæœ€å¤§çš„çº¿ç¨‹æ•°ï¼Œéæ ¸å¿ƒç©ºé—²çº¿ç¨‹AliveTimeï¼ŒAliveTimeçš„å•ä½ï¼Œä»¥åŠç”¨æ¥å­˜å‚¨ç­‰å¾…ä»»åŠ¡çš„é˜»å¡é˜Ÿåˆ—
//å¦‚æœé˜»å¡é˜Ÿåˆ—ç”¨ArrayBlockingQueueçš„è¯è¿˜è¦æŒ‡å®šæœ€å¤§å¤§å°
BlockingQueue<Runnable> blockingQueue =new LinkedBlockingQueue<>();
ThreadPoolExecutor executorService2 = new ThreadPoolExecutor(5,10,1000L, TimeUnit.SECONDS,blockingQueue);
```

è¿˜æœ‰å…«è‚¡é‡Œé¢å¸¸é—®çš„startå’Œrunçš„åŒºåˆ«ï¼Œrunå…¶å®å°±æ˜¯è°ƒç”¨ä¸€ä¸‹ä½ å®šä¹‰çš„çº¿ç¨‹è¦æ‰§è¡Œçš„æ–¹æ³•ï¼Œè€Œstartæ‰æ˜¯å¯åŠ¨çº¿ç¨‹ã€‚

çº¿ç¨‹çš„çŠ¶æ€åŒ…æ‹¬ï¼šnewã€runableã€blockedã€waitingã€timed_waitingã€terminated

### sleepå’Œwaitçš„åŒºåˆ«

è¿™æ˜¯æˆ‘å†³å®šå†™è¿™ç¯‡åšå®¢çš„å‡ºå‘ç‚¹ï¼Œä¸»è¦æ˜¯æˆ‘ä¸€å¼€å§‹ç«Ÿç„¶ä¸çŸ¥é“sleepä¸ä¼šé‡Šæ”¾å½“å‰å ç”¨çš„èµ„æºï¼Œå°±æ¯”å¦‚è¯´æˆ‘ç”¨synchronizedå…³é”®å­—åŒæ­¥ä½äº†ä¸€ä¸ªèµ„æºStringBuilderã€‚

å¦‚æœæˆ‘åœ¨åŒæ­¥å—å†…è°ƒç”¨äº†ä¸€ä¸‹sleep(0)ï¼Œè™½ç„¶çº¿ç¨‹ä¼šæ”¾å¼ƒå¯¹è¯¥æ—¶é—´ç‰‡çš„å ç”¨ï¼Œä½†æ˜¯å¹¶ä¸ä¼šé‡Šæ”¾èµ„æºã€‚

ä½†æ˜¯å¦‚æœåœ¨åŒæ­¥å—å†…ä½¿ç”¨wait()ï¼Œå°±ä¼šæ”¾å¼ƒå¯¹å½“å‰èµ„æºå’Œæ—¶é—´ç‰‡çš„å ç”¨ã€‚

åšä¸ªç®€å•çš„å®éªŒï¼Œå°±æ˜¯æœ€å¼€å§‹é‚£éƒ¨åˆ†çš„ä»£ç ï¼Œæˆ‘ä»¬å…ˆé€šè¿‡å®éªŒè¿›è¡Œå°è¯•ã€‚

```java
import java.util.Random;
import java.util.concurrent.*;

public class SleepTry {

    public static void main(String[] args) throws InterruptedException, ExecutionException {
        StringBuilder sb =new StringBuilder();
        BlockingQueue<Runnable> bq =new LinkedBlockingQueue<>();
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5,10,1000L, TimeUnit.SECONDS,bq);
        CountDownLatch countDownLatch = new CountDownLatch(2);
        Runnable task1 = new Runnable() {
            @Override
            public void run() {
                synchronized (sb){
                    sb.append("hello\n");
                    try {
                        Thread.sleep(2000);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    sb.append("I am Thread1\n");
                }
                countDownLatch.countDown();
            }
        };
        Runnable task2 = new Runnable() {
            @Override
            public void run() {
                synchronized (sb){
                    sb.append("I am Thread2\n");
                }
                countDownLatch.countDown();
            }
        };
        Future<?> feature1 =  threadPoolExecutor.submit(task1);
        Thread.sleep(10);
        Future<?> feature2 =  threadPoolExecutor.submit(task2);
        countDownLatch.await();
        //feature1.get();
        //feature2.get();
        System.out.println(sb.toString());
        threadPoolExecutor.shutdownNow();
    }
}
```

æˆ‘åœ¨åŒæ­¥å—é‡Œsleepäº†2sï¼Œå¦‚æœé‡Šæ”¾äº†èµ„æºï¼Œä¸€å®šæ˜¯å¤Ÿç¬¬äºŒä¸ªçº¿ç¨‹æŠŠè‡ªå·±çš„å†…å®¹åŠ è¿›å»çš„ã€‚

ä¸ºäº†è®©ä¸»è¿›ç¨‹ç­‰å¾…ä¸¤ä¸ªçº¿ç¨‹éƒ½æ‰§è¡Œå®Œï¼Œæˆ‘åŠ äº†ä¸€ä¸ªä¸¤æ­¥è®¡æ•°å™¨CountDownLatchï¼Œæ¯ä¸ªçº¿ç¨‹æ‰§è¡Œå®Œå°±å‡ä¸€ã€‚ç”¨è¢«æ³¨é‡Šæ‰çš„ä¸¤è¡Œgetå…¶å®ä¹Ÿå¯ä»¥ã€‚

ä½†æ˜¯å®é™…ç»“æœæ˜¯ï¼š

```
hello
I am Thread1
I am Thread2
```

æ˜¾ç„¶ï¼Œèµ„æºå¹¶æ²¡æœ‰å¾—åˆ°é‡Šæ”¾

æ­¤æ—¶åˆ«çš„ä»£ç éƒ½ä¸ä½œä¿®æ”¹ï¼Œåœ¨ä¸¤ä¸ªçº¿ç¨‹çš„åŒæ­¥å—å†…åˆ†åˆ«è°ƒç”¨wait()å’ŒnotifyAll()æ–¹æ³•

```java
import java.util.Random;
import java.util.concurrent.*;

public class SleepTry {

    public static void main(String[] args) throws InterruptedException, ExecutionException {
        StringBuilder sb =new StringBuilder();
        BlockingQueue<Runnable> bq =new LinkedBlockingQueue<>();
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5,10,1000L, TimeUnit.SECONDS,bq);
        CountDownLatch countDownLatch = new CountDownLatch(2);
        Runnable task1 = new Runnable() {
            @Override
            public void run() {
                synchronized (sb){
                    sb.append("hello\n");
                    try {
                        sb.wait();
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    sb.append("I am Thread1\n");
                }
                countDownLatch.countDown();
            }
        };
        Runnable task2 = new Runnable() {
            @Override
            public void run() {
                synchronized (sb){
                    sb.append("I am Thread2\n");
                    sb.notifyAll();
                }
                countDownLatch.countDown();
            }
        };
        Future<?> feature1 =  threadPoolExecutor.submit(task1);
        Thread.sleep(10);
        Future<?> feature2 =  threadPoolExecutor.submit(task2);
        //feature1.get();
        //feature2.get();
        countDownLatch.await();
        System.out.println(sb.toString());
        threadPoolExecutor.shutdownNow();
    }
}
```

ç»“æœå¦‚ä¸‹

```
hello
I am Thread2
I am Thread1
```

èµ„æºæˆåŠŸé‡Šæ”¾ï¼Œç¬¬äºŒä¸ªçº¿ç¨‹ä¹ŸæˆåŠŸå†™å…¥ã€‚

å¦‚æœç¬¬äºŒä¸ªçº¿ç¨‹ä¸notifyï¼Œè€Œä¸»è¿›ç¨‹åˆç­‰ç€çº¿ç¨‹1å‡å°‘è®¡æ•°å™¨ï¼Œé‚£ä¹ˆè¿›ç¨‹å°±ä¼šä¸€ç›´ç­‰å¾…ã€‚

æ‰€ä»¥æ­¤æ—¶æˆ‘ä»¬waitçš„æ—¶å€™å¯ä»¥åŠ ä¸ªtimeoutçš„å‚æ•°

```java
sb.wait(100);
```

æ‰€ä»¥å¾ˆå¤šå…«è‚¡å…¶å®æ€»ç»“çš„å¹¶ä¸å¥½ï¼Œwaitå¹¶ä¸ä¸€å®šéœ€è¦notifyæ‰èƒ½å”¤é†’ï¼Œä¹Ÿå¯ä»¥ä¸»åŠ¨è®¾å®štimeoutï¼Œè¶…æ—¶ä¹Ÿä¼šå”¤é†’ã€‚

#### å°å°æ€»ç»“ä¸€ä¸‹sleepå’Œwait

1. sleepæ–¹æ³•å±äºThreadç±»ï¼Œæ˜¯ä¸€ä¸ªé™æ€æ–¹æ³•ï¼Œä½œç”¨æ˜¯è®©å½“å‰çº¿ç¨‹è¿›å…¥sleepçŠ¶æ€ï¼›è€Œwaitæ˜¯ä¸€ä¸ªå®ä¾‹æ–¹æ³•ï¼Œå±äºObjectç±»ï¼Œå¿…é¡»è¢«ä¸€ä¸ªåˆå§‹åŒ–äº†çš„å®åŠ›å¯¹è±¡è°ƒç”¨

2. å¦‚æœå¤„äºåŒæ­¥å—å†…ï¼Œsleepä¸ä¼šé‡Šæ”¾èµ„æºï¼Œä½†æ˜¯waitä¼šé‡Šæ”¾èµ„æº

3. sleepå¯ä»¥ä¸åœ¨åŒæ­¥å—å†…è°ƒç”¨ï¼Œä½†æ˜¯waitä¸€å®šè¦åœ¨åŒæ­¥å—å†…è°ƒç”¨ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œä½ è¦é‡Šæ”¾è¿™ä¸ªèµ„æºï¼Œä½ å¿…é¡»æŒæœ‰è¿™ä¸ªèµ„æºçš„é”ï¼Œå¦åˆ™å°±ä¼šæŠ¥é”™å¦‚ä¸‹ï¼š

   ```java
   Exception in thread "main" java.util.concurrent.ExecutionException: java.lang.IllegalMonitorStateException: current thread is not owner
   	at java.base/java.util.concurrent.FutureTask.report(FutureTask.java:122)
   	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:191)
   	at SleepTry.main(SleepTry.java:44)
   Caused by: java.lang.IllegalMonitorStateException: current thread is not owner
   	at java.base/java.lang.Object.wait(Native Method)
   	at java.base/java.lang.Object.wait(Object.java:338)
   	at SleepTry$1.run(SleepTry.java:15)
   	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
   	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
   	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
   	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
   	at java.base/java.lang.Thread.run(Thread.java:833)
   ```

   

   

4. å”¤é†’æœºåˆ¶ï¼Œsleepåªèƒ½ç­‰å¾…è¶…æ—¶å”¤é†’ï¼Œä½†æ˜¯waitæ—¢å¯ä»¥è¶…æ—¶å”¤é†’ï¼Œä¹Ÿå¯ä»¥é€šè¿‡è¢«notify()æˆ–è€…notifyAll()å”¤é†’

æœ€åè¿™é‡Œè¡¥å……ä¸€ä¸‹notifyå’ŒnotifyAllçš„åŒºåˆ«ï¼Œè¿™æ˜¯å°æ—codingä¸Šå†™çš„ï¼Œè¯´çš„ç‰¹åˆ«å½¢è±¡

notifyï¼šå”¤èµ·ä¸€ä¸ªçº¿ç¨‹ï¼Œå…¶ä»–çº¿ç¨‹è¿˜å¤„äºwaitingçŠ¶æ€ï¼Œå¦‚æœè¿™ä¸ªçº¿ç¨‹ç»“æŸçš„æ—¶å€™æ²¡æœ‰notifyï¼Œé‚£ä¹ˆå…¶ä»–çº¿ç¨‹åªèƒ½ç»§ç»­ç­‰å¾…åˆ°è¶…æ—¶æˆ–è¢«ä¸­æ–­ã€‚è€Œä¸”notifyè¯´æ˜¯éšæœºå”¤é†’ï¼Œä½†æ˜¯åœ¨hotspotè™šæ‹Ÿæœºé‡Œæ˜¯å…ˆè¿›å…ˆå‡ºçš„å”¤é†’ã€‚

notifyAllï¼šæ‰€æœ‰çº¿ç¨‹éƒ½è¢«å”¤é†’ï¼Œç„¶åè¿›å…¥èµ„æºäº‰å¤ºç¯èŠ‚ï¼Œå–œé—»ä¹è§çš„BLOCKEDçŠ¶æ€

### çº¿ç¨‹çŠ¶æ€

ä¹‹å‰è¯´äº†çº¿ç¨‹çš„å…­ä¸ªçŠ¶æ€ï¼Œè¿™é‡Œå†æé†’è‡ªå·±é»˜å†™ä¸€ä¸‹ï¼š

NEWã€RUNABLEã€BLOCKEDã€WAITINGã€TIMED_WAITINGã€TERMINATED

BLOCKEDå’ŒWAITINGå…¶å®è¿˜æŒºéš¾åˆ†æ¸…æ¥šçš„ï¼Œæˆ‘æ€»ç»“ä¸ºä¸‹ï¼š

è™½ç„¶éƒ½æ˜¯é˜»å¡åœ¨é‚£é‡Œï¼Œä½†æ˜¯BLOCKEDæ˜¯å› ä¸ºèµ„æºç«äº‰å¯¼è‡´çš„é˜»å¡

WAITINGæ˜¯çº¿ç¨‹æ— é™æœŸåœ°ç­‰å¾…å¦ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œç‰¹å®šæ“ä½œï¼Œæ¯”å¦‚ä¸Šé¢æ‰€ä½¿ç”¨çš„CountDownLatchï¼Œå¦‚æœè°ƒç”¨await()æ–¹æ³•ï¼Œå…¶å®æ˜¯è¿›å…¥WAITINGçŠ¶æ€ï¼Œå’Œè°ƒç”¨waitæ–¹æ³•ç±»ä¼¼ã€‚

### çº¿ç¨‹åœæ­¢

è€ç”Ÿå¸¸è°ˆï¼Œå°±æ˜¯Javaå®˜æ–¹ä¸å»ºè®®ä½¿ç”¨Thread.stop()è¿™ç§æ–¹å¼æ¥åœæ­¢ã€‚

æœ‰å¾ˆå¤šç§æ–¹æ³•åŒ…æ‹¬

1. ä½¿ç”¨volatileå…³é”®å­—æ¥ä¿®é¥°ä¸€ä¸ªbooleanå˜é‡ï¼Œçº¿ç¨‹å…³æ³¨åˆ°booleanå˜é‡è‡ªå·±å†…éƒ¨åœæ­¢

2. è°ƒç”¨çº¿ç¨‹ä¸­æ–­Thread.interrupt()ï¼Œç„¶åçº¿ç¨‹å†…éƒ¨æ£€æµ‹å½“å‰çº¿ç¨‹æ˜¯å¦ä¸ºä¸­æ–­çŠ¶æ€æˆ–è€…è§¦å‘å¯ä¸­æ–­æ“ä½œæ¥å“åº”ä¸­æ–­ã€‚

   å¯è§¦å‘ä¸­æ–­æ“ä½œæ˜¯æŒ‡sleepæˆ–è€…waitç­‰é˜»å¡æ“ä½œï¼Œå¦‚æœè¿™æ—¶å€™æ”¶åˆ°ä¸­æ–­è¯·æ±‚ä¼šç›´æ¥æŠ›ä¸­æ–­å¼‚å¸¸çš„ã€‚

3. é€šè¿‡Futureç®¡ç†ä»»åŠ¡ï¼ŒFutureæ¥å£æ˜¯ä¸€ä¸ªå¯ä»¥ä¸»åŠ¨åœæ­¢ä»»åŠ¡çš„æ¥å£ï¼ŒFuture.cancel()

4. å…³é—­èµ„æº

## é”

### volatileå…³é”®å­—å’Œsynchronizedå…³é”®å­—

è¿™ä¸¤ä¸ªå…³é”®å­—æ€»æ˜¯è¢«æ‹¿å‡ºæ¥è¯´ï¼Œä½†å…¶å®ä¸¤è€…çš„ä½œç”¨å·®è·è¿˜æ˜¯æŒºå¤§çš„ã€‚

volatileçš„ä½œç”¨ä¸»è¦ä½“ç°åœ¨ç¦æ­¢æŒ‡ä»¤é‡æ’å¯¼è‡´çš„ä¿®æ”¹ä¸å¯è§ã€‚

è¿™ä¸ªğŸŒ°å…¶å®æŒºä¸å¥½ä¸¾çš„ï¼Œæˆ‘è¯•ç€çœ‹çœ‹èƒ½ä¸èƒ½å‡ºç°ã€‚å¤±è´¥äº†ï¼Œå¾ˆéš¾å¤ç°å•Šï¼Œå› ä¸ºå¹¶ä¸çŸ¥é“è™šæ‹Ÿæœºåº•å±‚æ˜¯å¦‚ä½•æŒ‡ä»¤é‡æ’å’Œä¼˜åŒ–çš„ã€‚

ä½†æ˜¯volatileå…³é”®å­—çš„ç›®çš„æ‰€åœ¨ï¼Œå°±æ˜¯ä¸ºäº†è®©çº¿ç¨‹çŸ¥é“ä¸€ä¸ªå˜é‡å®ƒå˜åŒ–äº†ï¼Œèƒ½æ„ŸçŸ¥åˆ°å®ƒçš„å˜åŒ–ï¼Œå€Ÿç”±æ­¤çº¿ç¨‹ä¹‹é—´å¯ä»¥ç›¸äº’é€šä¿¡ã€‚

ç„¶åè¯´è¯´volatileå…³é”®å­—çš„ä½œç”¨åŸŸï¼Œvolatileå…³é”®å­—ä¸»è¦ä½œç”¨äºå˜é‡å£°æ˜ä¸Šï¼Œæ›´å¤šçš„ç”¨äº**å®ä¾‹å˜é‡**æˆ–**é™æ€å˜é‡**ï¼Œæ‰€ä»¥å±€éƒ¨å˜é‡å£°æ˜æ— æ„ä¹‰ã€‚

### synchronizedå…³é”®å­—å’Œ ReentrantLock

æ¥ä¸‹æ¥å°±æ˜¯synchronizedå…³é”®å­—ï¼Œå…¶å®å®ƒæ›´åº”è¯¥å’ŒReentrantLockæ”¾åœ¨ä¸€èµ·æ¯”è¾ƒæ‰é€‚åˆï¼Œæ‰€ä»¥æˆ‘ä»¬æŠŠå®ƒæŒªåˆ°ä¸‹é¢æ¥

synchronizedå…³é”®å­—ä¸»è¦ç”¨äºå£°æ˜åŒæ­¥ï¼Œä¹Ÿå°±æ˜¯ç»™èµ„æºåŠ é”ã€‚

ä¸ReentrantLockç›¸åŒçš„ï¼Œsynchronizedä¹Ÿæ˜¯ä¸€ä¸ªå¯é‡å…¥é”ï¼Œä¹Ÿå°±æ˜¯åŒä¸€ä¸ªçº¿ç¨‹å†…å†æ¬¡ä¸Šé”ä¹Ÿå¯ä»¥è·å¾—èµ„æºã€‚

synchronizedæ˜¯Javaæä¾›çš„åŸå­å†…ç½®é”ï¼Œä¹Ÿè¢«ç§°ä¸ºç›‘è§†å™¨é”ã€‚

ä½¿ç”¨synchronizeå…³é”®å­—ä¿®é¥°çš„ä»£ç å—åœ¨ç¼–è¯‘çš„æ—¶å€™å‰åä¼šåˆ†åˆ«åŠ ä¸Šmonitorenterå’Œmonitorexitã€‚

è¿™ä¸ªæ‰§è¡Œåˆ°monitorenterçš„æ—¶å€™ä¼šå°è¯•è·å–èµ„æºï¼Œå¦‚æœè·å–åˆ°èµ„æºå°±æŠŠè®¡æ•°å™¨åŠ ä¸€ï¼Œæ‰§è¡Œåˆ°monitorexitçš„æ—¶å€™å°±æŠŠè®¡æ•°å™¨å‡ä¸€ã€‚ä¸º0çš„æ—¶å€™ä»£è¡¨æ˜¯å¯è·å–çš„ã€‚

æ¥ä¸‹æ¥æ˜¯synchronizedå…³é”®å­—çš„ä½œç”¨åŸŸï¼Œå…¶å®æŒºå¤æ‚çš„ï¼š

1. ä½œç”¨äºç±»çš„å®ä¾‹æ–¹æ³•ä¸Šï¼Œé‚£å°±æ˜¯é”ä½äº†å½“å‰å®ä¾‹ï¼ŒåŒä¸€æ—¶é—´åªèƒ½æœ‰ä¸€ä¸ªçº¿ç¨‹è®¿é—®è¯¥æ–¹æ³•çš„ä»»ä½• `synchronized` å®ä¾‹æ–¹æ³•ã€‚

   ```java
   import java.util.concurrent.LinkedBlockingQueue;
   import java.util.concurrent.ThreadPoolExecutor;
   import java.util.concurrent.TimeUnit;
   
   public class SynchronizedTry {
       public static class beBlocked{
           private int a;
           private int b=10;
           public synchronized int getA() throws InterruptedException {
               Thread.sleep(10000);
               return a;
           }
           public synchronized int getB(){
               return b;
           }
       }
   
       public static void main(String[] args) throws InterruptedException {
           beBlocked test = new beBlocked();
           Integer a = 10;
           ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5,10,1000L, TimeUnit.SECONDS,new LinkedBlockingQueue<>());
           threadPoolExecutor.submit(new Runnable() {
               @Override
               public void run() {
                   synchronized (a) {
                       try {
                           test.getA();
                       } catch (InterruptedException e) {
                           throw new RuntimeException(e);
                       }
                   }
               }
           });
           threadPoolExecutor.submit(new Runnable() {
               @Override
               public void run() {
                   int b =test.getB();
                   System.out.println(b);
               }
           });
           threadPoolExecutor.shutdown();
       }
   }
   ```

   ä»¥è¿™æ®µä»£ç ä¸ºä¾‹ï¼Œè°ƒç”¨getAæ–¹æ³•sleepçš„é‚£10sï¼Œå¦ä¸€ä¸ªçº¿ç¨‹æ˜¯æ²¡æœ‰åŠæ³•è·å¾—åˆ°å“ªæ€•æ˜¯getBæ–¹æ³•çš„è¿”å›å€¼çš„ã€‚

2. ä½œç”¨äºé™æ€æ–¹æ³•ï¼Œé‚£å°±ä¼šé”ä½ç±»å¯¹è±¡ï¼ŒåŒä¸€æ—¶é—´åªèƒ½æœ‰ä¸€ä¸ªçº¿ç¨‹è®¿é—®è¯¥æ–¹æ³•çš„ä»»ä½• `synchronized` é™æ€æ–¹æ³•ã€‚

3. ä½œç”¨äºä»£ç å—ï¼Œä¹Ÿå°±æ˜¯å¸¸ç”¨çš„synchronized(){}èŒƒå¼ï¼Œæ‹¬å·é‡Œå¯ä»¥ä¸ºObjectæˆ–è€…thisï¼Œä¹Ÿå¯ä»¥æ˜¯Classå¯¹è±¡

ReentrantLockç›¸æ¯”äºsynchronizedæ›´ä¸ºç²¾ç»†åŒ–ã€‚

å®ƒå®ç°äº†ä¸¤ä¸ªæ¥å£ï¼ŒLockæ¥å£å’Œåºåˆ—åŒ–æ¥å£

```java
public class ReentrantLock implements Lock, java.io.Serializable {
    private static final long serialVersionUID = 7373984872572414699L;
    /** Synchronizer providing all implementation mechanics */
    private final Sync sync;

    /**
     * Base of synchronization control for this lock. Subclassed
     * into fair and nonfair versions below. Uses AQS state to
     * represent the number of holds on the lock.
     */
    abstract static class Sync extends AbstractQueuedSynchronizer {
        private static final long serialVersionUID = -5179523762034025860L;

```

åŒæ­¥çš„å®ç°ä¸»è¦ä¾èµ–äºç»§æ‰¿è‡ªAbstractQueuedSynchronizerç±»ï¼ˆAQSï¼‰ç±»çš„Syncç±»

ReentrantLockæ˜¯å¯é‡å…¥é”ï¼Œä»åå­—å°±å¯ä»¥çœ‹å‡ºæ¥ï¼Œæ¯æ¬¡è·å–éƒ½éœ€è¦ç›¸åº”çš„é‡Šæ”¾æ“ä½œï¼Œé”å†…éƒ¨ç»´æŠ¤äº†ä¸€ä¸ªè®¡æ•°å™¨æ¥è®°å½•è·å–çš„æ¬¡æ•°ã€‚è¿™ç‚¹å’Œsynchronizedå…³é”®å­—å¾ˆåƒã€‚

å®ä¾‹åŒ–ReentrantLockçš„æ—¶å€™å¯ä»¥é€‰æ‹©æ˜¯å¦å¯ç”¨å…¬å¹³é”ã€‚å…¬å¹³é”ä¼šæŒ‰ç…§è¯·æ±‚é¡ºåºæˆäºˆé”ï¼Œè€Œéå…¬å¹³é”åˆ™å…è®¸æ’é˜Ÿï¼ˆå³æ–°æ¥çš„çº¿ç¨‹å¯èƒ½åœ¨ç­‰å¾…ä¸­çš„çº¿ç¨‹ä¹‹å‰è·å¾—é”ï¼‰ã€‚é»˜è®¤æ˜¯éå…¬å¹³é”ã€‚

```java
/**
 * Creates an instance of {@code ReentrantLock}.
 * This is equivalent to using {@code ReentrantLock(false)}.
 */
public ReentrantLock() {
    sync = new NonfairSync();
}

/**
 * Creates an instance of {@code ReentrantLock} with the
 * given fairness policy.
 *
 * @param fair {@code true} if this lock should use a fair ordering policy
 */
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
```

åŒæ—¶ReentrantLockæ”¯æŒä¸­æ–­å“åº”ï¼Œä¹Ÿå°±æ˜¯åœ¨ç­‰å¾…é”çš„æ—¶å€™åœ¨åŒæ­¥å—å†…å“åº”æ‰“æ–­ã€‚

åŒæ—¶ä¹Ÿæ”¯æŒéé˜»å¡å¼çš„è·å–é”ï¼ŒtryLockï¼Œå¦‚æœä¸èƒ½è·å¾—é”ï¼Œç«‹åˆ»è¿”å›ï¼Œä¹Ÿå¯ä»¥ä¼ å…¥ç­‰å¾…æ—¶é—´ã€‚

```java
ReentrantLock reentrantLock = new ReentrantLock(true);
reentrantLock.lockInterruptibly();
boolean flag = reentrantLock.tryLock(10, TimeUnit.MICROSECONDS);
```

### å…¶ä»–çš„é”

synchronizedå’ŒReentrantLockéƒ½æ˜¯æ’ä»–é”ï¼Œå…¶å®è¿˜æœ‰å¾ˆå¤šå…¶ä»–é”çš„ç±»å‹ã€‚

åƒæ˜¯ReadWriteLockï¼Œå†™é”æ˜¯ç‹¬å é”ï¼Œä½†æ˜¯è¯»é”æ˜¯å…±äº«é”ã€‚

ä»¥åŠä¸€äº›æ¦‚å¿µæ€§çš„é”ï¼Œä¹è§‚é”å’Œæ‚²è§‚é”ã€‚

ä¹è§‚é”å…¶å®æœ¬è´¨ä¸Šå°±æ˜¯å‡è®¾èµ„æºæ²¡äººç”¨ï¼Œæœ‰äººç”¨äº†æˆ‘å†é‡æ¥ã€‚æ‚²è§‚é”å°±æ˜¯synchronizedå’ŒReentrantLockè¿™æ ·çš„é”ï¼Œä¸€å®šè¦ç‹¬å äº†å†å»æ“ä½œã€‚

è‡ªæ—‹é”ä¸»è¦æ˜¯é CASå®ç°çš„ã€‚CASå…¨ç§°Compare And Setã€‚

æ¶‰åŠä¸‰ä¸ªå‚æ•°ï¼šå†…å­˜ä½ç½®ï¼ˆVï¼‰ã€é¢„æœŸåŸå€¼ï¼ˆAï¼‰å’Œæ–°å€¼ï¼ˆBï¼‰ã€‚CAS çš„æ‰§è¡Œé€»è¾‘å¦‚ä¸‹ï¼š

1. æ£€æŸ¥å†…å­˜ä½ç½® V ä¸­çš„å€¼æ˜¯å¦ç­‰äºé¢„æœŸåŸå€¼ Aã€‚
2. å¦‚æœç›¸ç­‰ï¼Œåˆ™å°†å†…å­˜ä½ç½® V çš„å€¼æ›´æ–°ä¸ºæ–°å€¼ Bï¼Œå¹¶è¿”å›æˆåŠŸã€‚
3. å¦‚æœä¸ç›¸ç­‰ï¼Œè¯´æ˜æœ‰å…¶ä»–çº¿ç¨‹å·²ç»ä¿®æ”¹äº†è¯¥ä½ç½®çš„å€¼ï¼Œåˆ™ä¸è¿›è¡Œä»»ä½•æ“ä½œï¼Œå¹¶è¿”å›å¤±è´¥ã€‚

è¿™å…¶å®æ˜¯ä¹è§‚é”çš„ä¸€ç§å®ç°ã€‚Javaçš„åŸå­ç±»æ¯”å¦‚AtomicIntegerå°±æä¾›è¿™ç§ç±»å‹çš„æ–¹æ³•ï¼šcompareAndSet

```java
/**
 * Atomically sets the value to {@code newValue}
 * if the current value {@code == expectedValue},
 * with memory effects as specified by {@link VarHandle#compareAndSet}.
 *
 * @param expectedValue the expected value
 * @param newValue the new value
 * @return {@code true} if successful. False return indicates that
 * the actual value was not equal to the expected value.
 */
public final boolean compareAndSet(int expectedValue, int newValue) {
    return U.compareAndSetInt(this, VALUE, expectedValue, newValue);
}
```

### sychronized

sychronizedçš„é”å‡çº§è¿‡ç¨‹ï¼š

æ— é”->åå‘é”->è½»é‡çº§é”->é‡é‡çº§é”

åå‘é”æ˜¯JAVA1.6å¼•å…¥çš„ï¼Œå½“ä¸€ä¸ªçº¿ç¨‹æ‹¿åˆ°é”ä¹‹åï¼Œä¼šè®°å½•å®ƒçš„çº¿ç¨‹IDï¼Œå¦‚æœæ²¡æœ‰ç«äº‰æ—¶ï¼Œåªéœ€è¦æ¯”è¾ƒè®°å½•çš„IDä¸è‡ªå·±æ˜¯å¦ä¸€è‡´ï¼Œä¸€è‡´ç›´æ¥è·å¾—é”ï¼Œä¸éœ€è¦CASæ“ä½œã€‚

å½“æœ‰é”ç«äº‰çš„æ—¶å€™ï¼Œåå‘é”å‡çº§ä¸ºè½»é‡çº§é”ã€‚è¿™æ—¶å€™çš„é”é€šè¿‡CASå®ç°ï¼Œå…è®¸è‡ªæ—‹ã€‚

å½“ç«äº‰æ¿€çƒˆçš„æ—¶å€™ï¼Œè½»é‡çº§é”å‡çº§ä¸ºé‡é‡çº§é”ï¼Œç³»ç»ŸæŒ‚èµ·çº¿ç¨‹è€Œä¸æ˜¯çº¿ç¨‹è‡ªæ—‹ã€‚

### AQS

å…¨åä¸ºæŠ½è±¡åŒæ­¥é˜Ÿåˆ—ï¼Œå®ç°åŒæ­¥çš„é‡è¦åº•å±‚ä¹‹ä¸€ã€‚

ä¸»è¦ç»´æŠ¤ä¸€ä¸ªé˜»å¡é˜Ÿåˆ—å’Œä¸€ä¸ªstateã€‚å¦‚æœstateä¸º0æˆ–è€…ä¸ºåŒçº¿ç¨‹ï¼ˆå¯é‡å…¥é”ï¼‰ï¼Œåˆ™å¯è·å¾—é”ï¼Œè®¡æ•°å™¨+1ï¼›

ç«äº‰å¤±è´¥çš„çº¿ç¨‹åŠ å…¥åˆ°é˜»å¡é˜Ÿåˆ—ä¸­å»ï¼Œå¦‚æœæ˜¯å…¬å¹³é”ï¼Œæ–°æ¥çš„çº¿ç¨‹ç›´æ¥åŠ å…¥åˆ°é˜»å¡é˜Ÿåˆ—ä¸­å»

### éå…¬å¹³é”ä¸ºä»€ä¹ˆæ¯”å…¬å¹³é”ååé‡å¤§

å› ä¸ºéå…¬å¹³é”è·å–çº¿ç¨‹CASå¦‚æœè·å–åˆ°é”ç›´æ¥å°±æ‹¥æœ‰é”ï¼Œä¸éœ€è¦è¿›è¡Œä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚

### æ­»é”æ¡ä»¶

1. äº’æ–¥æ¡ä»¶
2. æ‹¥æœ‰å¹¶ç­‰å¾…
3. ä¸å¯å‰¥å¤º
4. èµ„æºä¾èµ–ç¯è·¯
